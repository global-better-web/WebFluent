// part of this code from: https://github.com/tylerlaceby/guide-to-interpreters-series
// -----------------------------------------------------------
// ---------------          LEXER          -------------------
// ---  Responsible for producing tokens from the source   ---
// -----------------------------------------------------------

import { Token, TokenType } from "./types.ts";

const KEYWORDS: Record<string, TokenType> = {
  Component: TokenType.Component,
  Column: TokenType.Column,
  export: TokenType.Export,
  Page: TokenType.Page,
  Row: TokenType.Row,
  Input: TokenType.Input,
  Text: TokenType.Text,
  src: TokenType.src,
  Image: TokenType.Image,
  Style: TokenType.Style,
  Display: TokenType.Display,
  Place: TokenType.Place,
  Padding: TokenType.Padding,
  FontColor: TokenType.FontColor,
  Font: TokenType.Font,
  Border: TokenType.Border,
  Background: TokenType.Background,

};

export class Lexer {
  private source: string;
  // current lexer position
  private pos: number;

  //this is used to idintify the position of errors excatly
  private line: number;
  private column: number;

  // identifiy the current charctar
  private currentChar: string | null;

  // store the tokens here before return them
  private tokens: Array<Token>;

  /**
   * Creates a new Lexer object to tokenize the given source code.
   *
   * @remarks
   * The `Lexer` object is used to break the input source code into individual tokens for parsing.
   * The `sourceCode` parameter should be a string containing the source code to tokenize.
   *
   * @param sourceCode - The source code to tokenize.
   */
  constructor(sourceCode: string) {
    /**
     * The input source code to tokenize.
     */
    this.source = sourceCode;

    /**
     * The current position of the lexer in the input source code.
     */
    this.pos = 0;

    /**
     * The current line number of the lexer in the input source code.
     */
    this.line = 1;

    /**
     * The current column number of the lexer in the input source code.
     */
    this.column = 1;

    /**
     * The current character being processed by the lexer.
     */
    this.currentChar = this.source.charAt(this.pos);

    /**
     * An array to hold the tokens generated by the lexer.
     */
    this.tokens = [];
  }

  /**
   * Advances the lexer's current position to the next character in the input string.
   * If the end of the input string is reached, sets the current character to `null`.
   * Updates the lexer's column position if a new character is encountered.
   */
  private advance(): void {
    this.pos++;
    if (this.pos >= this.source.length) {
      this.currentChar = null;
    } else {
      this.currentChar = this.source.charAt(this.pos);
      this.column++;
    }    
  }

  /**
   * Advances the lexer's current position past any whitespace characters in the input string.
   * Updates the lexer's line and column position if a newline character is encountered.
   */
  private skipWhitespace(): void {
    while (this.currentChar !== null && /\s/.test(this.currentChar)) {
      if (this.currentChar === "\n") {
        this.line++;
        this.column = 1;
      }
      this.advance();
    }
    // Skip over comments
    if (this.currentChar === "/" && this.source.charAt(this.pos + 1) === "/") {
      // deno-lint-ignore ban-ts-comment
      //@ts-ignore
      while (this.currentChar !== "\n" && this.currentChar !== null) {
        this.advance();
      }
      this.skipWhitespace(); // Recursively skip any whitespace after the comment
    }
  }

  /**
   * Reads an identifier from the input string and returns it as a string.
   * An identifier is a sequence of one or more letters or digits, starting with a letter.
   * If the current character is a digit, throws an error indicating that the input is invalid.
   *
   * @throws Error if the current character is a digit, indicating that the input is invalid.
   * @returns The identifier as a string.
   */
  private readIdentifier(): string {
    let result = "";
    while (
      (this.currentChar !== null && /[a-zA-Z]/.test(this.currentChar)) ||
      this.isint(this.currentChar as string)
    ) {
      result += this.currentChar;
      if (this.isint(this.currentChar as string)) {
        throw new Error(
          `Hold on a sec take a look at ${
            this.tokens[this.tokens.length - 1].line
          }:${
            this.tokens[this.tokens.length - 1].column
          } We dont have that here`
        );
      }
      this.advance();
    }
    return result;
  }

  private readHexColorCode(): string {
    let result = "";
    if (this.currentChar === "#") {
      result += this.currentChar;
      this.advance();
    }
    while (
      this.currentChar !== null &&
      /[0-9a-fA-F]/.test(this.currentChar)
    ) {
      result += this.currentChar;
      this.advance();
    }
    return result;
  }

  /**
   * Returns whether the character passed in alphabetic -> [a-zA-Z]
   */
  private isalpha(src: string): boolean {
    return src.toUpperCase() != src.toLowerCase();
  }

  /**
   * Returns true if the character is whitespace like -> [\s, \t, \n]
   */
  private isskippable(str: string) {
    return str == " " || str == "\n" || str == "\t" || str == "\r"
      ? true
      : false;
  }

  /**
 Return whether the character is a valid integer -> [0-9]
 */
  private isint(str: string) {
    const c = str.charCodeAt(0);
    const bounds = ["0".charCodeAt(0), "9".charCodeAt(0)];
    return c >= bounds[0] && c <= bounds[1];
  }

  // Returns a token of a given type and value
  private addToken(value = "", type: TokenType): void {
    this.tokens.push({ value, type, line: this.line, column: this.column });
  }

  /**
   * Checks whether a given string is a valid hexadecimal color code.
   *
   * @param str - The string to check.
   * @returns `true` if the string is a valid hexadecimal color code, `false` otherwise.
   */
  private isHexColorCode(str: string): boolean {
    // Match the string against the regular expression for a valid hexadecimal color code
    const regex = /^#([0-9A-Fa-f]{3}){1,2}$/;
    return regex.test(str);
  }

  private getString(): string {
    let result = '';
    this.advance();
    while (this.currentChar !== '"' && this.currentChar !== null) {
      result += this.currentChar;
      this.advance();
    }
    if (this.currentChar !== null && this.currentChar !== '"') {
      this.advance();
    }
    return result;
  }

  /**
   * Tokenizes the input source code and returns an array of tokens.
   *
   * @remarks
   * The `tokenize` method uses the `Lexer` object to break the input source code into individual tokens.
   * The method returns an array of `Token` objects, each representing a single token in the source code.
   *
   * @returns An array of `Token` objects representing the individual tokens in the input source code.
   *
   * @throws Error if the input source code contains an invalid character or token.
   */
  tokenize(): Token[] {
    while (this.currentChar !== null) {
      if (this.isskippable(this.currentChar)) {
        this.skipWhitespace();
        continue;
      } else if (this.currentChar === "{") {
        /**
         * Adds an `OpenBrace` token and advances to the next character.
         */
        this.addToken("{", TokenType.OpenBrace);
        this.advance();
      } else if (this.currentChar === "}") {
        /**
         * Adds a `CloseBrace` token and advances to the next character.
         */
        this.addToken("}", TokenType.CloseBrace);
        this.advance();

      } else if (this.currentChar === ":") {
        /**
         * Adds a `Colon` token and advances to the next character.
         */
        this.addToken(":", TokenType.Colon);
        this.advance();

      } else if (this.currentChar === '"') {
        /**
         * Adds a `StringLiteral` token and advances to the next character.
         */
        const value: string = this.getString();
        this.addToken(value, TokenType.String);
        this.advance();

      } else if (this.currentChar === '.') {
        /**
         * Adds a Dot Token and then advance
         */
        this.addToken('.', TokenType.Dot);
        this.advance();

      } else if (this.currentChar === ',') {
        /**
         * Adds a Dot Token and then advance
         */
        this.addToken(',', TokenType.Coma);
        this.advance();

      } else if (this.currentChar === "") {
        /**
         * if there is no code just exit
         */
        Deno.exit(0);
      } else if (this.currentChar === "(") {
        /**
         * Adds a `OpenParen` token and advances to the next character.
         */
        this.addToken("(", TokenType.OpenParen);
        this.advance();
        
      } else if (this.currentChar === ")") {
        /**
         * Adds a `CloseParen` token and advances to the next character.
         */
        this.addToken(")", TokenType.CloseParen);
        this.advance();
        
      } else if (this.isint(this.currentChar)) {
        /**
         * Adds a `CloseParen` token and advances to the next character.
         */
        this.addToken(this.currentChar, TokenType.Number);
        this.advance();
        
      } else if (this.currentChar === "#") {
        /**
         * Adds a `CloseParen` token and advances to the next character.
         */
        const colorCode = this.readHexColorCode();
        
        
        if (this.isHexColorCode(colorCode)){
          this.addToken(colorCode, TokenType.HexColor);
        } else {
          throw new Error(`Color Code: ${colorCode} is not valid`)
        }
        
        
      } else if (this.isalpha(this.currentChar)) {
        /**
         * Reads an identifier and checks if it is a reserved keyword.
         * Adds an `Identifier`, `Component`, `Column`, or `Export` token as appropriate.
         */
        const identifier = this.readIdentifier();
        
        const reserved = KEYWORDS[identifier];        

        if (reserved === TokenType.Component) {
          this.addToken(identifier, TokenType.Component);
          
        } else if (reserved === TokenType.Column) {
          this.addToken(identifier, TokenType.Column);

        } else if (reserved === TokenType.Export) {
          this.addToken(identifier, TokenType.Export);

        } else if (reserved === TokenType.Page) {
          this.addToken(identifier, TokenType.Page);

        } else if (reserved === TokenType.Row) {
          this.addToken(identifier, TokenType.Row);

        } else if (reserved === TokenType.Input) {
          this.addToken(identifier, TokenType.Input);

        } else if (reserved === TokenType.Text) {
          this.addToken(identifier, TokenType.Text);

        } else if (reserved === TokenType.Image) {
          this.addToken(identifier, TokenType.Image);

        } else if (reserved === TokenType.src) {
          this.addToken(identifier, TokenType.src);

        } else if (reserved === TokenType.Style) {
          this.addToken(identifier, TokenType.Style);

        } else if (reserved === TokenType.Place) {
          this.addToken(identifier, TokenType.Place);

        } else if (reserved === TokenType.Padding) {
          this.addToken(identifier, TokenType.Padding);

        } else if (reserved === TokenType.Display) {
          this.addToken(identifier, TokenType.Display);

        } else if (reserved === TokenType.Font) {
          this.addToken(identifier, TokenType.Font);

        } else if (reserved === TokenType.Border) {
          this.addToken(identifier, TokenType.Border);

        } else if (reserved === TokenType.Background) {
          this.addToken(identifier, TokenType.Background);

        } else if (reserved === TokenType.FontColor) {
          this.addToken(identifier, TokenType.FontColor);

        } else if (this.isHexColorCode(identifier)) {
          this.addToken(identifier, TokenType.HexColor);

        } else {
          this.addToken(identifier, TokenType.Identifier);
        }
      } else {
        console.log(this.tokens);
        
        /**
         * Throws an error for an invalid character or token.
         */
        throw new Error(`Invalid character: ${this.currentChar}`);
      }
    }

    /**
     * Adds an `EndOfFile` token to mark the end of the input source code.
     */
    this.addToken("EndOfFile", TokenType.EOF);

    /**
     * Returns an array of `Token` objects representing the individual tokens in the input source code.
     */
    return this.tokens;
  }
}
